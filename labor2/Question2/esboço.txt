EXERCÍCIO 2A

A seguir, a tabela contendo o código de cada operação realizada pela ULA e a descrição de suas funções, juntamente com o código verilog.


(Tabela 2a)


EXERCÍCIO 2B

Assumindo que iControl realizará todas as operações da ULA, podemos verificar através da seguinte simulação RTL que os resultados batem com o esperado:

(2b-1.png)

Entradas:

iA = 0x00000001
iB = 0x00000002
iControl = Todas as operações da ULA

Saídas:

Observe os 4 últimos bits das entradas iA e iB para cada operação que se segue

Realizando uma operação AND
0001 AND 0010 = 0000
iA   AND iB   = 0x0

Realizando uma operação OR
0001 OR 0010 = 0011
iA   OR iB   = 0x3

Realizando uma operação XOR
0001 XOR 0010 = 0011
iA   XOR iB   = 0x3

Realizando uma operação ADD
0001 + 0010 = 0011
1    + 2    = 3
iA   + iB   = 0x3

Realizando uma operação SUB. Como 1 - 2 = -1, o resultado deve ser um número negativo e já que trabalhamos com números em complemento de 2 no RISCV o resultado da operação deve ser -1 em complemento de 2, ou seja:
0x00000001 - 0x00000002 = 0xffffffff
iA  	   - 	iB   	= 0xffffffff

Realizando uma operação SLT, como 1 é menor do que 2, a operação é verdadeira, logo:
0001 < 0010 = 0001
iA   < iB   = 0x1

Realizando uma operação SLTU
0001 + 0010 = 0011
1    + 2    = 3
iA   + iB   = 0x3

Realizando uma operação SLL
0001 + 0010 = 0011
1    + 2    = 3
iA   + iB   = 0x3

Realizando uma operação SRL
0001 + 0010 = 0011
1    + 2    = 3
iA   + iB   = 0x3



Agora, existem alguns casos especiais que valem a pena serem examinados, como os casos onde ocorrem overflow e ou underflow:
Operações que valem a pena serem examinadas: 
ADD (0x7fffffff, 0x7fffffff)
ADD (0x80000000, 0x80000000)

SUB (0x7fffffff, 0x7fffffff)
SUB (0x80000000, 0x80000000)

		OPSLT:
		OPSLTU:
		OPSLL:
		OPSRL:
		OPSRA:
			
		OPLUI:
			oResult  <= iB;
			
`ifndef RV32I	//	Modulo de multiplicacao e divisao
		OPMUL:
			oResult  <= mul[31:0];
		OPMULH:
			oResult  <= mul[63:32];
		OPMULHU:
			oResult  <= mulu[63:32];
		OPMULHSU:
			oResult  <= mulsu[63:32];	
		OPDIV:
			oResult  <= iA / iB;
		OPDIVU:
			oResult  <= $unsigned(iA) / $unsigned(iB);
		OPREM:
			oResult  <= iA % iB;
		OPREMU:
			oResult  <= $unsigned(iA) % $unsigned(iB);	